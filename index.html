<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solaris 3D Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 0; }
        
        /* Custom Scrollbar for the list */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.1); }
        ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.3); border-radius: 3px; }
        
        /* Glassmorphism Utilities */
        .glass {
            background: rgba(20, 20, 25, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.008);
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body class="font-sans antialiased selection:bg-blue-500 selection:text-white">

    <div id="canvas-container"></div>

    <div class="absolute inset-0 pointer-events-none flex flex-col md:flex-row z-10">
        
        <div class="absolute top-0 left-0 p-6 pointer-events-auto">
            <h1 class="text-4xl font-bold tracking-tighter text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500">SOLARIS</h1>
            <p class="text-sm text-gray-400 mt-1">Interactive 3D System Explorer</p>
        </div>

        <div class="absolute bottom-0 left-0 w-full md:w-auto md:top-24 md:bottom-auto md:left-6 p-4 pointer-events-auto">
            <div class="glass rounded-xl p-4 md:w-64 max-h-[30vh] md:max-h-[70vh] overflow-y-auto flex flex-row md:flex-col gap-2 overflow-x-auto">
                <div id="planet-list" class="flex md:flex-col gap-2">
                </div>
            </div>
        </div>

        <div class="absolute bottom-6 right-6 md:top-24 md:bottom-auto w-[90%] md:w-80 pointer-events-auto transition-all duration-500 transform translate-y-0 opacity-100" id="info-panel">
            <div class="glass rounded-xl p-6">
                <div class="flex items-center justify-between mb-2">
                    <h2 id="info-name" class="text-2xl font-bold text-white">The Sun</h2>
                    <span id="info-type" class="text-xs font-mono px-2 py-1 rounded">STAR</span> 
                </div>
                <p id="info-desc" class="text-gray-300 text-sm leading-relaxed">The star around which the earth and other astronomical objects orbit. It provides the light and energy that sustains life on Earth.</p>
                
                <div class="mt-4 grid grid-cols-2 gap-3 text-xs">
                    <div class="bg-white/5 p-2 rounded">
                        <span class="block text-gray-500">Distance from Sun</span>
                        <span id="info-dist" class="block text-white font-mono">0 AU</span>
                    </div>
                    <div class="bg-white/5 p-2 rounded">
                        <span class="block text-gray-500">Year Length</span>
                        <span id="info-year" class="block text-white font-mono">--</span>
                    </div>
                </div>
                
                <button id="reset-cam" class="mt-4 w-full bg-white/10 hover:bg-white/20 text-white py-2 rounded transition text-sm font-semibold border border-white/10">
                    Reset View
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration ---
        const CONFIG = {
            rotationSpeed: 0.2, // Global orbit speed multiplier
            orbitScale: 15,     // Spacing between planets (not strictly used, but good for context)
            zoomFactor: 4,      // Multiplier to determine zoom distance relative to planet size
            smoothness: 0.05    // Camera smoothing factor (Lower is slower)
        };

        // --- Planet Data (Colors converted to standard hex strings for easy parsing) ---
        const PLANETS = [
            {
                name: "Sun",
                size: 12,
                color: "#ffaa00", 
                emissive: "#ff4400",
                distance: 0,
                speed: 0,
                desc: "The heart of our solar system. A nearly perfect sphere of hot plasma, radiating energy.",
                type: "STAR",
                year: "--"
            },
            {
                name: "Mercury",
                size: 1.2,
                color: "#A5A5A5",
                distance: 20,
                speed: 0.04,
                desc: "The smallest planet in the Solar System and the closest to the Sun.",
                type: "TERRESTRIAL",
                year: "88 Days"
            },
            {
                name: "Venus",
                size: 2.4,
                color: "#E3BB76",
                distance: 30,
                speed: 0.015,
                desc: "The second planet from the Sun. It has a thick atmosphere that traps heat.",
                type: "TERRESTRIAL",
                year: "225 Days",
                hasGlow: true, 
                glowColor: "#ffd000" 
            },
            {
                name: "Earth",
                size: 2.5,
                color: "#2233FF",
                distance: 45,
                speed: 0.01,
                desc: "Our home. The only known planet in the universe to support life.",
                type: "TERRESTRIAL",
                year: "365 Days",
                hasGlow: true, 
                glowColor: "#00ffff" 
            },
            {
                name: "Mars",
                size: 1.8,
                color: "#FF4500",
                distance: 60,
                speed: 0.008,
                desc: "The Red Planet. Dusty, cold, desert world with a very thin atmosphere.",
                type: "TERRESTRIAL",
                year: "687 Days"
            },
            {
                name: "Jupiter",
                size: 7,
                color: "#D9A066",
                distance: 90,
                speed: 0.002,
                desc: "The largest planet in the Solar System. A gas giant with a Great Red Spot.",
                type: "GAS GIANT",
                year: "12 Years"
            },
            {
                name: "Saturn",
                size: 6,
                color: "#EAD6B8",
                distance: 125,
                speed: 0.0009,
                hasRing: true,
                desc: "Adorned with a dazzling system of icy rings, Saturn is unique among the planets.",
                type: "GAS GIANT",
                year: "29 Years"
            },
            {
                name: "Uranus",
                size: 4,
                color: "#D1F3F6",
                distance: 160,
                speed: 0.0004,
                desc: "An ice giant. It rotates at a nearly 90-degree angle from the plane of its orbit.",
                type: "ICE GIANT",
                year: "84 Years"
            },
            {
                name: "Neptune",
                size: 3.9,
                color: "#3E54E8",
                distance: 190,
                speed: 0.0001,
                desc: "The most distant major planet. Dark, cold, and whipped by supersonic winds.",
                type: "ICE GIANT",
                year: "165 Years"
            }
        ];

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 80, 150);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxDistance = 400;

        // Vector to store the camera's target position for smooth transition
        const targetCameraPosition = new THREE.Vector3();
        targetCameraPosition.copy(camera.position); 


        // --- Lights ---
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5); 
        scene.add(ambientLight);

        // Sun light at the origin
        const sunLight = new THREE.PointLight(0xffffff, 6, 400); 
        sunLight.position.set(0, 0, 0);
        scene.add(sunLight);

        // --- Starfield ---
        function createStars() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < 3000; i++) {
                vertices.push(
                    THREE.MathUtils.randFloatSpread(800),
                    THREE.MathUtils.randFloatSpread(800),
                    THREE.MathUtils.randFloatSpread(800)
                );
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7, transparent: true, opacity: 0.8 });
            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }
        createStars();


        // --- Helper Function for Glow Effect ---
        function createPlanetGlow(mesh, colorHex) {
            const loader = new THREE.TextureLoader();
            // Note: Using a local texture path is safer than a threejs.org example path
            // For this live demo, the existing link is kept.
            const glowTexture = loader.load('https://threejs.org/examples/textures/sprites/glow.png'); 

            const glowMaterial = new THREE.SpriteMaterial({
                map: glowTexture,
                color: new THREE.Color(colorHex), // Use THREE.Color
                transparent: true,
                blending: THREE.AdditiveBlending, 
                opacity: 0.6
            });
            const glowSprite = new THREE.Sprite(glowMaterial);
            
            const glowScale = mesh.geometry.parameters.radius * 4; 
            glowSprite.scale.set(glowScale, glowScale, 1.0);

            mesh.add(glowSprite);
        }


        // --- Objects Management ---
        const planetMeshes = [];
        let focusedPlanet = null; 

        // --- Planet Creation ---
        PLANETS.forEach((data) => {
            const group = new THREE.Group();
            const planetColor = new THREE.Color(data.color); // Convert hex string to THREE.Color

            // Orbit Ring (Visual aid)
            if (data.distance > 0) {
                const ringGeometry = new THREE.RingGeometry(data.distance - 0.2, data.distance + 0.2, 128);
                const ringMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff, 
                    side: THREE.DoubleSide, 
                    transparent: true, 
                    opacity: 0.1 
                });
                const orbitRing = new THREE.Mesh(ringGeometry, ringMaterial);
                orbitRing.rotation.x = Math.PI / 2;
                scene.add(orbitRing);
            }

            // Planet Mesh
            const geometry = new THREE.SphereGeometry(data.size, 32, 32);

            if (data.name === "Sun") {
                const emissiveColor = new THREE.Color(data.emissive); // Convert hex string to THREE.Color
                const material = new THREE.MeshBasicMaterial({ 
                    color: planetColor, 
                    emissive: emissiveColor, 
                    emissiveIntensity: 1.2 
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.userData = data; 
                group.add(mesh);
                scene.add(group);
                planetMeshes.push({ mesh: mesh, group: group, data: data, angle: 0 });

            } else {
                const material = new THREE.MeshStandardMaterial({ color: planetColor }); 
                const mesh = new THREE.Mesh(geometry, material);
                
                mesh.userData = data;

                // Saturn's Rings
                if (data.hasRing) {
                    const ringGeo = new THREE.RingGeometry(data.size * 1.4, data.size * 2.2, 64);
                    // CHANGED: Use MeshBasicMaterial for the rings as they are not lit 
                    // and StandardMaterial is often too dark for thin planes.
                    const ringMat = new THREE.MeshBasicMaterial({ 
                        color: new THREE.Color(0xaa8866), 
                        side: THREE.DoubleSide, 
                        transparent: true, 
                        opacity: 0.6 
                    });
                    const saturnRing = new THREE.Mesh(ringGeo, ringMat);
                    saturnRing.rotation.x = Math.PI / 2; 
                    saturnRing.rotation.y = 0.2; 
                    mesh.add(saturnRing);
                }

                if (data.hasGlow) {
                    createPlanetGlow(mesh, data.glowColor);
                }

                mesh.position.x = data.distance;
                group.add(mesh);
                scene.add(group);
                
                planetMeshes.push({
                    mesh: mesh,
                    group: group,
                    data: data,
                    angle: Math.random() * Math.PI * 2 
                });
            }
        });


        // --- UI Logic ---
        const planetList = document.getElementById('planet-list');
        const infoName = document.getElementById('info-name');
        const infoDesc = document.getElementById('info-desc');
        const infoType = document.getElementById('info-type');
        const infoDist = document.getElementById('info-dist');
        const infoYear = document.getElementById('info-year');
        const resetBtn = document.getElementById('reset-cam');

        // Helper map for setting UI tag color
        const typeColors = {
            "STAR": "bg-yellow-500/20 text-yellow-300",
            "TERRESTRIAL": "bg-green-500/20 text-green-300",
            "GAS GIANT": "bg-red-500/20 text-red-300",
            "ICE GIANT": "bg-blue-500/20 text-blue-300"
        };


        function updateInfo(data) {
            infoName.innerText = data.name;
            infoDesc.innerText = data.desc;
            infoType.innerText = data.type;
            infoDist.innerText = data.distance + " AU (Scaled)";
            infoYear.innerText = data.year;
            
            // UI Improvement: Update the tag color based on planet type
            const typeClass = typeColors[data.type] || "bg-gray-500/20 text-gray-300";
            infoType.className = `text-xs font-mono px-2 py-1 rounded ${typeClass}`;

            document.querySelectorAll('.planet-btn').forEach(btn => {
                btn.classList.remove('bg-blue-600', 'border-blue-400', 'ring-2', 'ring-blue-400');
                btn.classList.add('bg-white/5', 'border-transparent');
            });
            const activeBtn = document.getElementById(`btn-${data.name}`);
            if(activeBtn) {
                activeBtn.classList.remove('bg-white/5', 'border-transparent');
                // Added a ring class for better visual focus
                activeBtn.classList.add('bg-blue-600', 'border-blue-400', 'ring-2', 'ring-blue-400');
            }
        }
        
        // Sets the `focusedPlanet` and the `targetCameraPosition`
        function focusOnPlanet(planetObj) {
            focusedPlanet = planetObj;
            updateInfo(planetObj.data);

            const pPos = planetObj.mesh.position;
            const offsetDistance = 10 + (planetObj.data.size * CONFIG.zoomFactor);
            
            // Calculate a new camera position offset from the planet's current position (pPos)
            // This is the desired END position for the camera.
            targetCameraPosition.set(
                pPos.x + offsetDistance,
                pPos.y + offsetDistance * 0.3, // Slightly elevated view
                pPos.z + offsetDistance
            );

            // Set controls target immediately to the planet's position
            controls.target.set(pPos.x, pPos.y, pPos.z);
            controls.update(); 
        }

        PLANETS.forEach(p => {
            const btn = document.createElement('button');
            btn.id = `btn-${p.name}`;
            btn.className = 'planet-btn flex items-center gap-3 p-2 rounded-lg bg-white/5 hover:bg-white/10 border border-transparent transition-all w-full text-left';
            btn.innerHTML = `
                <div class="w-3 h-3 rounded-full shadow-[0_0_8px_rgba(255,255,255,0.5)]" style="background-color: ${p.color}"></div> 
                <span class="text-sm font-medium text-gray-200">${p.name}</span>
            `;
            btn.onclick = () => {
                const target = planetMeshes.find(pm => pm.data.name === p.name);
                focusOnPlanet(target);
            };
            planetList.appendChild(btn);
        });

        // Reset button now also resets the target camera position
        resetBtn.onclick = () => {
            focusedPlanet = null;
            
            // Reset controls target
            controls.target.set(0,0,0);
            
            // Set camera target position to initial view
            targetCameraPosition.set(0, 80, 150);
            
            updateInfo(PLANETS[0]); 
        };

        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            // Smoothly move the actual camera towards the targetCameraPosition
            camera.position.lerp(targetCameraPosition, CONFIG.smoothness);
            
            // Rotate Planets
            planetMeshes.forEach(obj => {
                // Orbit Logic
                if (obj.data.distance > 0) {
                    obj.angle += obj.data.speed * CONFIG.rotationSpeed;
                    obj.mesh.position.x = Math.cos(obj.angle) * obj.data.distance;
                    obj.mesh.position.z = Math.sin(obj.angle) * obj.data.distance;
                }
                
                // Self Rotation
                obj.mesh.rotation.y += 0.005;
            });

            // Camera Tracking Logic
            // The controls.update() is necessary for damping and camera manipulation
            controls.update();
            
            if (focusedPlanet) {
                const pPos = focusedPlanet.mesh.position;
                
                // 1. Continuously update the controls target to follow the orbiting planet
                const targetVec = new THREE.Vector3(pPos.x, pPos.y, pPos.z);
                controls.target.lerp(targetVec, 0.05); 
                
                // 2. IMPORTANT: When focused, we also need to continuously move the camera position
                // to maintain the offset relative to the *moving* planet and the *user-rotated* camera view.
                
                // Calculate the vector from the control's target (the planet) to the current camera position
                const offsetVector = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
                
                // Define the desired distance based on planet size (used for setting targetCameraPosition)
                const desiredDistance = 10 + (focusedPlanet.data.size * CONFIG.zoomFactor);
                
                // Set the new camera target position to be the planet position plus the scaled offset vector
                // This ensures the camera position smoothly follows the planet while respecting user rotation
                targetCameraPosition.copy(controls.target).addScaledVector(offsetVector, desiredDistance);
            }

            renderer.render(scene, camera);
        }

        // --- Resize Handler ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize view: Focus on the Sun and start animation
        focusOnPlanet(planetMeshes[0]);
        animate();

    </script>
</body>
</html>
